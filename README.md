# BruteForce-Greedy

### 반복과 재귀
- 반복과 재귀는 유사한 작업을 수행
- 반복 : 수행하는 작업이 완료될 떄까지
  - 루프(for, while 구조)
  1. 초기화 : 명령문을 실행하기 전에 (한번만) 조건 검사에 사용할 변수의 초기값 설정
  2. 조건검사
  3. 반복할 명령문 실행
  4. 업데이트
- 재귀 : 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용
  - 하나의 큰 문제를 해결할 수 있는 더 작은문제로 쪼개고 결과들을 결합
  - 재귀 함수
    - 함수 내부에서 직, 간접적으로 자기 자신을 호출하는 함수
    - 반복구조에 비해 간결하고 이해하기 쉬움
    - 함수 호출은 스택을 사용, 재귀 호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하가 발생
- 일반적으로, 재귀적 알고리즘은 반복 알고리즘보다 더 많은 메모리와 연산을 요함

### Brute-force(완전 검색 기법)
- 대부분의 문제에 적용이 가능
- 상대적으로 빠른 시간에 문제 해결(알고리즘 설계) 가능
- 문제에 포함된 자료(요소, 인스턴스)의 크기가 작다면 유용
- 완전 검색을 기반으로 greedy나 DP를 이용해서 효율적인 알고리즘을 찾을 수 있음

#### 순열
- 순열(Permutation)
  - 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
  - 순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련
  - n개의 요소들에 대해서 n!개의 순열들이 존재
  - 최소한의 변경을 통해 순열을 생성하는 방법
    - Johnson-Trotter 알고리즘

#### 부분집합
- 집합에 포함된 원소들을 선택하는 것
- 중요 알고리즘들이 원소들의 그룹에서 최적의 부분집합을 찾는 것과 관련
- 생성 방법
  - 바이너리 카운팅
    - 부분집합을 생성하기 위한 가장 자연스러운 방법
    - 원소 수에 해당하는 N개으 ㅣ비트열을 이용
    - n번째 비트 값이 1이면 n번째 원소가 포함되었음을 의미
    
#### 조합
- 조합(Combination)
  - 서로 다른 n개의 원소 중 r개를 순서에 상관없이 골라낸 것
  
### 탐욕 알고리즘
- 최적해를 구하는데 사용되는 근시안적인 방법
- 일반적으로, 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy 접근
- 각 선택 시점에서 이루어지는 결정은 **지역적으로 최적**이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, **그 것이 최적이라는 보장은 없음**
- 최적화 문제 : 가능한 해들 중에서 가장 좋은 해를 찾는 문제
1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 solution set에 추가
2. 실행 가능성 검사 : 새로운 해 집합이 실행가능한지를 확인(제약 조건 위반 여부)
3. 해 검사 : 문제의 해가 되는지를 확인

// to be continued
